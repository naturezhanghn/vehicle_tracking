// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tron.proto

#ifndef PROTOBUF_tron_2eproto__INCLUDED
#define PROTOBUF_tron_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tron {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tron_2eproto();
void protobuf_AssignDesc_tron_2eproto();
void protobuf_ShutdownFile_tron_2eproto();

class Argument;
class Blob;
class MetaNetParam;
class ModelInfo;
class NetParam;
class OpParam;

// ===================================================================

class Blob : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tron.Blob) */ {
 public:
  Blob();
  virtual ~Blob();

  Blob(const Blob& from);

  inline Blob& operator=(const Blob& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Blob& default_instance();

  void Swap(Blob* other);

  // implements Message ----------------------------------------------

  inline Blob* New() const { return New(NULL); }

  Blob* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Blob& from);
  void MergeFrom(const Blob& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Blob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // repeated int32 shape = 3;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 3;
  ::google::protobuf::int32 shape(int index) const;
  void set_shape(int index, ::google::protobuf::int32 value);
  void add_shape(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shape();

  // repeated float data_f = 4 [packed = true];
  int data_f_size() const;
  void clear_data_f();
  static const int kDataFFieldNumber = 4;
  float data_f(int index) const;
  void set_data_f(int index, float value);
  void add_data_f(float value);
  const ::google::protobuf::RepeatedField< float >&
      data_f() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_data_f();

  // repeated int32 data_i = 5 [packed = true];
  int data_i_size() const;
  void clear_data_i();
  static const int kDataIFieldNumber = 5;
  ::google::protobuf::int32 data_i(int index) const;
  void set_data_i(int index, ::google::protobuf::int32 value);
  void add_data_i(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      data_i() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_data_i();

  // repeated bytes data_b = 6;
  int data_b_size() const;
  void clear_data_b();
  static const int kDataBFieldNumber = 6;
  const ::std::string& data_b(int index) const;
  ::std::string* mutable_data_b(int index);
  void set_data_b(int index, const ::std::string& value);
  void set_data_b(int index, const char* value);
  void set_data_b(int index, const void* value, size_t size);
  ::std::string* add_data_b();
  void add_data_b(const ::std::string& value);
  void add_data_b(const char* value);
  void add_data_b(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& data_b() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data_b();

  // @@protoc_insertion_point(class_scope:tron.Blob)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shape_;
  ::google::protobuf::RepeatedField< float > data_f_;
  mutable int _data_f_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > data_i_;
  mutable int _data_i_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_b_;
  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static Blob* default_instance_;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tron.Argument) */ {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Argument& default_instance();

  void Swap(Argument* other);

  // implements Message ----------------------------------------------

  inline Argument* New() const { return New(NULL); }

  Argument* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Argument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional float s_f = 2;
  bool has_s_f() const;
  void clear_s_f();
  static const int kSFFieldNumber = 2;
  float s_f() const;
  void set_s_f(float value);

  // optional int32 s_i = 3;
  bool has_s_i() const;
  void clear_s_i();
  static const int kSIFieldNumber = 3;
  ::google::protobuf::int32 s_i() const;
  void set_s_i(::google::protobuf::int32 value);

  // optional string s_s = 4;
  bool has_s_s() const;
  void clear_s_s();
  static const int kSSFieldNumber = 4;
  const ::std::string& s_s() const;
  void set_s_s(const ::std::string& value);
  void set_s_s(const char* value);
  void set_s_s(const char* value, size_t size);
  ::std::string* mutable_s_s();
  ::std::string* release_s_s();
  void set_allocated_s_s(::std::string* s_s);

  // repeated float v_f = 5;
  int v_f_size() const;
  void clear_v_f();
  static const int kVFFieldNumber = 5;
  float v_f(int index) const;
  void set_v_f(int index, float value);
  void add_v_f(float value);
  const ::google::protobuf::RepeatedField< float >&
      v_f() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_v_f();

  // repeated int32 v_i = 6;
  int v_i_size() const;
  void clear_v_i();
  static const int kVIFieldNumber = 6;
  ::google::protobuf::int32 v_i(int index) const;
  void set_v_i(int index, ::google::protobuf::int32 value);
  void add_v_i(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      v_i() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_v_i();

  // repeated string v_s = 7;
  int v_s_size() const;
  void clear_v_s();
  static const int kVSFieldNumber = 7;
  const ::std::string& v_s(int index) const;
  ::std::string* mutable_v_s(int index);
  void set_v_s(int index, const ::std::string& value);
  void set_v_s(int index, const char* value);
  void set_v_s(int index, const char* value, size_t size);
  ::std::string* add_v_s();
  void add_v_s(const ::std::string& value);
  void add_v_s(const char* value);
  void add_v_s(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& v_s() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_v_s();

  // @@protoc_insertion_point(class_scope:tron.Argument)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_s_f();
  inline void clear_has_s_f();
  inline void set_has_s_i();
  inline void clear_has_s_i();
  inline void set_has_s_s();
  inline void clear_has_s_s();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  float s_f_;
  ::google::protobuf::int32 s_i_;
  ::google::protobuf::internal::ArenaStringPtr s_s_;
  ::google::protobuf::RepeatedField< float > v_f_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > v_i_;
  ::google::protobuf::RepeatedPtrField< ::std::string> v_s_;
  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static Argument* default_instance_;
};
// -------------------------------------------------------------------

class OpParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tron.OpParam) */ {
 public:
  OpParam();
  virtual ~OpParam();

  OpParam(const OpParam& from);

  inline OpParam& operator=(const OpParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpParam& default_instance();

  void Swap(OpParam* other);

  // implements Message ----------------------------------------------

  inline OpParam* New() const { return New(NULL); }

  OpParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpParam& from);
  void MergeFrom(const OpParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // repeated string bottom = 3;
  int bottom_size() const;
  void clear_bottom();
  static const int kBottomFieldNumber = 3;
  const ::std::string& bottom(int index) const;
  ::std::string* mutable_bottom(int index);
  void set_bottom(int index, const ::std::string& value);
  void set_bottom(int index, const char* value);
  void set_bottom(int index, const char* value, size_t size);
  ::std::string* add_bottom();
  void add_bottom(const ::std::string& value);
  void add_bottom(const char* value);
  void add_bottom(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& bottom() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bottom();

  // repeated string top = 4;
  int top_size() const;
  void clear_top();
  static const int kTopFieldNumber = 4;
  const ::std::string& top(int index) const;
  ::std::string* mutable_top(int index);
  void set_top(int index, const ::std::string& value);
  void set_top(int index, const char* value);
  void set_top(int index, const char* value, size_t size);
  ::std::string* add_top();
  void add_top(const ::std::string& value);
  void add_top(const char* value);
  void add_top(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& top() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_top();

  // repeated .tron.Argument arg = 11;
  int arg_size() const;
  void clear_arg();
  static const int kArgFieldNumber = 11;
  const ::tron::Argument& arg(int index) const;
  ::tron::Argument* mutable_arg(int index);
  ::tron::Argument* add_arg();
  ::google::protobuf::RepeatedPtrField< ::tron::Argument >*
      mutable_arg();
  const ::google::protobuf::RepeatedPtrField< ::tron::Argument >&
      arg() const;

  // @@protoc_insertion_point(class_scope:tron.OpParam)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> bottom_;
  ::google::protobuf::RepeatedPtrField< ::std::string> top_;
  ::google::protobuf::RepeatedPtrField< ::tron::Argument > arg_;
  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static OpParam* default_instance_;
};
// -------------------------------------------------------------------

class NetParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tron.NetParam) */ {
 public:
  NetParam();
  virtual ~NetParam();

  NetParam(const NetParam& from);

  inline NetParam& operator=(const NetParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetParam& default_instance();

  void Swap(NetParam* other);

  // implements Message ----------------------------------------------

  inline NetParam* New() const { return New(NULL); }

  NetParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetParam& from);
  void MergeFrom(const NetParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .tron.Blob blob = 5;
  int blob_size() const;
  void clear_blob();
  static const int kBlobFieldNumber = 5;
  const ::tron::Blob& blob(int index) const;
  ::tron::Blob* mutable_blob(int index);
  ::tron::Blob* add_blob();
  ::google::protobuf::RepeatedPtrField< ::tron::Blob >*
      mutable_blob();
  const ::google::protobuf::RepeatedPtrField< ::tron::Blob >&
      blob() const;

  // repeated .tron.OpParam op = 11;
  int op_size() const;
  void clear_op();
  static const int kOpFieldNumber = 11;
  const ::tron::OpParam& op(int index) const;
  ::tron::OpParam* mutable_op(int index);
  ::tron::OpParam* add_op();
  ::google::protobuf::RepeatedPtrField< ::tron::OpParam >*
      mutable_op();
  const ::google::protobuf::RepeatedPtrField< ::tron::OpParam >&
      op() const;

  // repeated .tron.Argument arg = 12;
  int arg_size() const;
  void clear_arg();
  static const int kArgFieldNumber = 12;
  const ::tron::Argument& arg(int index) const;
  ::tron::Argument* mutable_arg(int index);
  ::tron::Argument* add_arg();
  ::google::protobuf::RepeatedPtrField< ::tron::Argument >*
      mutable_arg();
  const ::google::protobuf::RepeatedPtrField< ::tron::Argument >&
      arg() const;

  // @@protoc_insertion_point(class_scope:tron.NetParam)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::tron::Blob > blob_;
  ::google::protobuf::RepeatedPtrField< ::tron::OpParam > op_;
  ::google::protobuf::RepeatedPtrField< ::tron::Argument > arg_;
  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static NetParam* default_instance_;
};
// -------------------------------------------------------------------

class ModelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tron.ModelInfo) */ {
 public:
  ModelInfo();
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo& default_instance();

  void Swap(ModelInfo* other);

  // implements Message ----------------------------------------------

  inline ModelInfo* New() const { return New(NULL); }

  ModelInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string project = 1;
  bool has_project() const;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // optional string version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string method = 3;
  bool has_method() const;
  void clear_method();
  static const int kMethodFieldNumber = 3;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // @@protoc_insertion_point(class_scope:tron.ModelInfo)
 private:
  inline void set_has_project();
  inline void clear_has_project();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_method();
  inline void clear_has_method();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static ModelInfo* default_instance_;
};
// -------------------------------------------------------------------

class MetaNetParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tron.MetaNetParam) */ {
 public:
  MetaNetParam();
  virtual ~MetaNetParam();

  MetaNetParam(const MetaNetParam& from);

  inline MetaNetParam& operator=(const MetaNetParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaNetParam& default_instance();

  void Swap(MetaNetParam* other);

  // implements Message ----------------------------------------------

  inline MetaNetParam* New() const { return New(NULL); }

  MetaNetParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaNetParam& from);
  void MergeFrom(const MetaNetParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetaNetParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .tron.ModelInfo model_info = 2;
  bool has_model_info() const;
  void clear_model_info();
  static const int kModelInfoFieldNumber = 2;
  const ::tron::ModelInfo& model_info() const;
  ::tron::ModelInfo* mutable_model_info();
  ::tron::ModelInfo* release_model_info();
  void set_allocated_model_info(::tron::ModelInfo* model_info);

  // repeated .tron.NetParam network = 11;
  int network_size() const;
  void clear_network();
  static const int kNetworkFieldNumber = 11;
  const ::tron::NetParam& network(int index) const;
  ::tron::NetParam* mutable_network(int index);
  ::tron::NetParam* add_network();
  ::google::protobuf::RepeatedPtrField< ::tron::NetParam >*
      mutable_network();
  const ::google::protobuf::RepeatedPtrField< ::tron::NetParam >&
      network() const;

  // repeated .tron.Argument arg = 12;
  int arg_size() const;
  void clear_arg();
  static const int kArgFieldNumber = 12;
  const ::tron::Argument& arg(int index) const;
  ::tron::Argument* mutable_arg(int index);
  ::tron::Argument* add_arg();
  ::google::protobuf::RepeatedPtrField< ::tron::Argument >*
      mutable_arg();
  const ::google::protobuf::RepeatedPtrField< ::tron::Argument >&
      arg() const;

  // @@protoc_insertion_point(class_scope:tron.MetaNetParam)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_model_info();
  inline void clear_has_model_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::tron::ModelInfo* model_info_;
  ::google::protobuf::RepeatedPtrField< ::tron::NetParam > network_;
  ::google::protobuf::RepeatedPtrField< ::tron::Argument > arg_;
  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static MetaNetParam* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Blob

// optional string name = 1;
inline bool Blob::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Blob::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Blob::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Blob::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Blob::name() const {
  // @@protoc_insertion_point(field_get:tron.Blob.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Blob::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tron.Blob.name)
}
inline void Blob::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tron.Blob.name)
}
inline void Blob::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tron.Blob.name)
}
inline ::std::string* Blob::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tron.Blob.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Blob::release_name() {
  // @@protoc_insertion_point(field_release:tron.Blob.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Blob::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tron.Blob.name)
}

// optional string type = 2;
inline bool Blob::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Blob::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Blob::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Blob::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Blob::type() const {
  // @@protoc_insertion_point(field_get:tron.Blob.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Blob::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tron.Blob.type)
}
inline void Blob::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tron.Blob.type)
}
inline void Blob::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tron.Blob.type)
}
inline ::std::string* Blob::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:tron.Blob.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Blob::release_type() {
  // @@protoc_insertion_point(field_release:tron.Blob.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Blob::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:tron.Blob.type)
}

// repeated int32 shape = 3;
inline int Blob::shape_size() const {
  return shape_.size();
}
inline void Blob::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int32 Blob::shape(int index) const {
  // @@protoc_insertion_point(field_get:tron.Blob.shape)
  return shape_.Get(index);
}
inline void Blob::set_shape(int index, ::google::protobuf::int32 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:tron.Blob.shape)
}
inline void Blob::add_shape(::google::protobuf::int32 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:tron.Blob.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Blob::shape() const {
  // @@protoc_insertion_point(field_list:tron.Blob.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Blob::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:tron.Blob.shape)
  return &shape_;
}

// repeated float data_f = 4 [packed = true];
inline int Blob::data_f_size() const {
  return data_f_.size();
}
inline void Blob::clear_data_f() {
  data_f_.Clear();
}
inline float Blob::data_f(int index) const {
  // @@protoc_insertion_point(field_get:tron.Blob.data_f)
  return data_f_.Get(index);
}
inline void Blob::set_data_f(int index, float value) {
  data_f_.Set(index, value);
  // @@protoc_insertion_point(field_set:tron.Blob.data_f)
}
inline void Blob::add_data_f(float value) {
  data_f_.Add(value);
  // @@protoc_insertion_point(field_add:tron.Blob.data_f)
}
inline const ::google::protobuf::RepeatedField< float >&
Blob::data_f() const {
  // @@protoc_insertion_point(field_list:tron.Blob.data_f)
  return data_f_;
}
inline ::google::protobuf::RepeatedField< float >*
Blob::mutable_data_f() {
  // @@protoc_insertion_point(field_mutable_list:tron.Blob.data_f)
  return &data_f_;
}

// repeated int32 data_i = 5 [packed = true];
inline int Blob::data_i_size() const {
  return data_i_.size();
}
inline void Blob::clear_data_i() {
  data_i_.Clear();
}
inline ::google::protobuf::int32 Blob::data_i(int index) const {
  // @@protoc_insertion_point(field_get:tron.Blob.data_i)
  return data_i_.Get(index);
}
inline void Blob::set_data_i(int index, ::google::protobuf::int32 value) {
  data_i_.Set(index, value);
  // @@protoc_insertion_point(field_set:tron.Blob.data_i)
}
inline void Blob::add_data_i(::google::protobuf::int32 value) {
  data_i_.Add(value);
  // @@protoc_insertion_point(field_add:tron.Blob.data_i)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Blob::data_i() const {
  // @@protoc_insertion_point(field_list:tron.Blob.data_i)
  return data_i_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Blob::mutable_data_i() {
  // @@protoc_insertion_point(field_mutable_list:tron.Blob.data_i)
  return &data_i_;
}

// repeated bytes data_b = 6;
inline int Blob::data_b_size() const {
  return data_b_.size();
}
inline void Blob::clear_data_b() {
  data_b_.Clear();
}
inline const ::std::string& Blob::data_b(int index) const {
  // @@protoc_insertion_point(field_get:tron.Blob.data_b)
  return data_b_.Get(index);
}
inline ::std::string* Blob::mutable_data_b(int index) {
  // @@protoc_insertion_point(field_mutable:tron.Blob.data_b)
  return data_b_.Mutable(index);
}
inline void Blob::set_data_b(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tron.Blob.data_b)
  data_b_.Mutable(index)->assign(value);
}
inline void Blob::set_data_b(int index, const char* value) {
  data_b_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tron.Blob.data_b)
}
inline void Blob::set_data_b(int index, const void* value, size_t size) {
  data_b_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tron.Blob.data_b)
}
inline ::std::string* Blob::add_data_b() {
  // @@protoc_insertion_point(field_add_mutable:tron.Blob.data_b)
  return data_b_.Add();
}
inline void Blob::add_data_b(const ::std::string& value) {
  data_b_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tron.Blob.data_b)
}
inline void Blob::add_data_b(const char* value) {
  data_b_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tron.Blob.data_b)
}
inline void Blob::add_data_b(const void* value, size_t size) {
  data_b_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tron.Blob.data_b)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Blob::data_b() const {
  // @@protoc_insertion_point(field_list:tron.Blob.data_b)
  return data_b_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Blob::mutable_data_b() {
  // @@protoc_insertion_point(field_mutable_list:tron.Blob.data_b)
  return &data_b_;
}

// -------------------------------------------------------------------

// Argument

// optional string name = 1;
inline bool Argument::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Argument::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Argument::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Argument::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Argument::name() const {
  // @@protoc_insertion_point(field_get:tron.Argument.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tron.Argument.name)
}
inline void Argument::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tron.Argument.name)
}
inline void Argument::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tron.Argument.name)
}
inline ::std::string* Argument::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tron.Argument.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument::release_name() {
  // @@protoc_insertion_point(field_release:tron.Argument.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tron.Argument.name)
}

// optional float s_f = 2;
inline bool Argument::has_s_f() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Argument::set_has_s_f() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Argument::clear_has_s_f() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Argument::clear_s_f() {
  s_f_ = 0;
  clear_has_s_f();
}
inline float Argument::s_f() const {
  // @@protoc_insertion_point(field_get:tron.Argument.s_f)
  return s_f_;
}
inline void Argument::set_s_f(float value) {
  set_has_s_f();
  s_f_ = value;
  // @@protoc_insertion_point(field_set:tron.Argument.s_f)
}

// optional int32 s_i = 3;
inline bool Argument::has_s_i() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Argument::set_has_s_i() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Argument::clear_has_s_i() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Argument::clear_s_i() {
  s_i_ = 0;
  clear_has_s_i();
}
inline ::google::protobuf::int32 Argument::s_i() const {
  // @@protoc_insertion_point(field_get:tron.Argument.s_i)
  return s_i_;
}
inline void Argument::set_s_i(::google::protobuf::int32 value) {
  set_has_s_i();
  s_i_ = value;
  // @@protoc_insertion_point(field_set:tron.Argument.s_i)
}

// optional string s_s = 4;
inline bool Argument::has_s_s() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Argument::set_has_s_s() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Argument::clear_has_s_s() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Argument::clear_s_s() {
  s_s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s_s();
}
inline const ::std::string& Argument::s_s() const {
  // @@protoc_insertion_point(field_get:tron.Argument.s_s)
  return s_s_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_s_s(const ::std::string& value) {
  set_has_s_s();
  s_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tron.Argument.s_s)
}
inline void Argument::set_s_s(const char* value) {
  set_has_s_s();
  s_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tron.Argument.s_s)
}
inline void Argument::set_s_s(const char* value, size_t size) {
  set_has_s_s();
  s_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tron.Argument.s_s)
}
inline ::std::string* Argument::mutable_s_s() {
  set_has_s_s();
  // @@protoc_insertion_point(field_mutable:tron.Argument.s_s)
  return s_s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument::release_s_s() {
  // @@protoc_insertion_point(field_release:tron.Argument.s_s)
  clear_has_s_s();
  return s_s_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_s_s(::std::string* s_s) {
  if (s_s != NULL) {
    set_has_s_s();
  } else {
    clear_has_s_s();
  }
  s_s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s_s);
  // @@protoc_insertion_point(field_set_allocated:tron.Argument.s_s)
}

// repeated float v_f = 5;
inline int Argument::v_f_size() const {
  return v_f_.size();
}
inline void Argument::clear_v_f() {
  v_f_.Clear();
}
inline float Argument::v_f(int index) const {
  // @@protoc_insertion_point(field_get:tron.Argument.v_f)
  return v_f_.Get(index);
}
inline void Argument::set_v_f(int index, float value) {
  v_f_.Set(index, value);
  // @@protoc_insertion_point(field_set:tron.Argument.v_f)
}
inline void Argument::add_v_f(float value) {
  v_f_.Add(value);
  // @@protoc_insertion_point(field_add:tron.Argument.v_f)
}
inline const ::google::protobuf::RepeatedField< float >&
Argument::v_f() const {
  // @@protoc_insertion_point(field_list:tron.Argument.v_f)
  return v_f_;
}
inline ::google::protobuf::RepeatedField< float >*
Argument::mutable_v_f() {
  // @@protoc_insertion_point(field_mutable_list:tron.Argument.v_f)
  return &v_f_;
}

// repeated int32 v_i = 6;
inline int Argument::v_i_size() const {
  return v_i_.size();
}
inline void Argument::clear_v_i() {
  v_i_.Clear();
}
inline ::google::protobuf::int32 Argument::v_i(int index) const {
  // @@protoc_insertion_point(field_get:tron.Argument.v_i)
  return v_i_.Get(index);
}
inline void Argument::set_v_i(int index, ::google::protobuf::int32 value) {
  v_i_.Set(index, value);
  // @@protoc_insertion_point(field_set:tron.Argument.v_i)
}
inline void Argument::add_v_i(::google::protobuf::int32 value) {
  v_i_.Add(value);
  // @@protoc_insertion_point(field_add:tron.Argument.v_i)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Argument::v_i() const {
  // @@protoc_insertion_point(field_list:tron.Argument.v_i)
  return v_i_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Argument::mutable_v_i() {
  // @@protoc_insertion_point(field_mutable_list:tron.Argument.v_i)
  return &v_i_;
}

// repeated string v_s = 7;
inline int Argument::v_s_size() const {
  return v_s_.size();
}
inline void Argument::clear_v_s() {
  v_s_.Clear();
}
inline const ::std::string& Argument::v_s(int index) const {
  // @@protoc_insertion_point(field_get:tron.Argument.v_s)
  return v_s_.Get(index);
}
inline ::std::string* Argument::mutable_v_s(int index) {
  // @@protoc_insertion_point(field_mutable:tron.Argument.v_s)
  return v_s_.Mutable(index);
}
inline void Argument::set_v_s(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tron.Argument.v_s)
  v_s_.Mutable(index)->assign(value);
}
inline void Argument::set_v_s(int index, const char* value) {
  v_s_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tron.Argument.v_s)
}
inline void Argument::set_v_s(int index, const char* value, size_t size) {
  v_s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tron.Argument.v_s)
}
inline ::std::string* Argument::add_v_s() {
  // @@protoc_insertion_point(field_add_mutable:tron.Argument.v_s)
  return v_s_.Add();
}
inline void Argument::add_v_s(const ::std::string& value) {
  v_s_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tron.Argument.v_s)
}
inline void Argument::add_v_s(const char* value) {
  v_s_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tron.Argument.v_s)
}
inline void Argument::add_v_s(const char* value, size_t size) {
  v_s_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tron.Argument.v_s)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Argument::v_s() const {
  // @@protoc_insertion_point(field_list:tron.Argument.v_s)
  return v_s_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Argument::mutable_v_s() {
  // @@protoc_insertion_point(field_mutable_list:tron.Argument.v_s)
  return &v_s_;
}

// -------------------------------------------------------------------

// OpParam

// optional string name = 1;
inline bool OpParam::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpParam::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpParam::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpParam::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& OpParam::name() const {
  // @@protoc_insertion_point(field_get:tron.OpParam.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpParam::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tron.OpParam.name)
}
inline void OpParam::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tron.OpParam.name)
}
inline void OpParam::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tron.OpParam.name)
}
inline ::std::string* OpParam::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tron.OpParam.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpParam::release_name() {
  // @@protoc_insertion_point(field_release:tron.OpParam.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpParam::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tron.OpParam.name)
}

// optional string type = 2;
inline bool OpParam::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpParam::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpParam::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpParam::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& OpParam::type() const {
  // @@protoc_insertion_point(field_get:tron.OpParam.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpParam::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tron.OpParam.type)
}
inline void OpParam::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tron.OpParam.type)
}
inline void OpParam::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tron.OpParam.type)
}
inline ::std::string* OpParam::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:tron.OpParam.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpParam::release_type() {
  // @@protoc_insertion_point(field_release:tron.OpParam.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpParam::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:tron.OpParam.type)
}

// repeated string bottom = 3;
inline int OpParam::bottom_size() const {
  return bottom_.size();
}
inline void OpParam::clear_bottom() {
  bottom_.Clear();
}
inline const ::std::string& OpParam::bottom(int index) const {
  // @@protoc_insertion_point(field_get:tron.OpParam.bottom)
  return bottom_.Get(index);
}
inline ::std::string* OpParam::mutable_bottom(int index) {
  // @@protoc_insertion_point(field_mutable:tron.OpParam.bottom)
  return bottom_.Mutable(index);
}
inline void OpParam::set_bottom(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tron.OpParam.bottom)
  bottom_.Mutable(index)->assign(value);
}
inline void OpParam::set_bottom(int index, const char* value) {
  bottom_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tron.OpParam.bottom)
}
inline void OpParam::set_bottom(int index, const char* value, size_t size) {
  bottom_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tron.OpParam.bottom)
}
inline ::std::string* OpParam::add_bottom() {
  // @@protoc_insertion_point(field_add_mutable:tron.OpParam.bottom)
  return bottom_.Add();
}
inline void OpParam::add_bottom(const ::std::string& value) {
  bottom_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tron.OpParam.bottom)
}
inline void OpParam::add_bottom(const char* value) {
  bottom_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tron.OpParam.bottom)
}
inline void OpParam::add_bottom(const char* value, size_t size) {
  bottom_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tron.OpParam.bottom)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OpParam::bottom() const {
  // @@protoc_insertion_point(field_list:tron.OpParam.bottom)
  return bottom_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OpParam::mutable_bottom() {
  // @@protoc_insertion_point(field_mutable_list:tron.OpParam.bottom)
  return &bottom_;
}

// repeated string top = 4;
inline int OpParam::top_size() const {
  return top_.size();
}
inline void OpParam::clear_top() {
  top_.Clear();
}
inline const ::std::string& OpParam::top(int index) const {
  // @@protoc_insertion_point(field_get:tron.OpParam.top)
  return top_.Get(index);
}
inline ::std::string* OpParam::mutable_top(int index) {
  // @@protoc_insertion_point(field_mutable:tron.OpParam.top)
  return top_.Mutable(index);
}
inline void OpParam::set_top(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tron.OpParam.top)
  top_.Mutable(index)->assign(value);
}
inline void OpParam::set_top(int index, const char* value) {
  top_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tron.OpParam.top)
}
inline void OpParam::set_top(int index, const char* value, size_t size) {
  top_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tron.OpParam.top)
}
inline ::std::string* OpParam::add_top() {
  // @@protoc_insertion_point(field_add_mutable:tron.OpParam.top)
  return top_.Add();
}
inline void OpParam::add_top(const ::std::string& value) {
  top_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tron.OpParam.top)
}
inline void OpParam::add_top(const char* value) {
  top_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tron.OpParam.top)
}
inline void OpParam::add_top(const char* value, size_t size) {
  top_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tron.OpParam.top)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OpParam::top() const {
  // @@protoc_insertion_point(field_list:tron.OpParam.top)
  return top_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OpParam::mutable_top() {
  // @@protoc_insertion_point(field_mutable_list:tron.OpParam.top)
  return &top_;
}

// repeated .tron.Argument arg = 11;
inline int OpParam::arg_size() const {
  return arg_.size();
}
inline void OpParam::clear_arg() {
  arg_.Clear();
}
inline const ::tron::Argument& OpParam::arg(int index) const {
  // @@protoc_insertion_point(field_get:tron.OpParam.arg)
  return arg_.Get(index);
}
inline ::tron::Argument* OpParam::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:tron.OpParam.arg)
  return arg_.Mutable(index);
}
inline ::tron::Argument* OpParam::add_arg() {
  // @@protoc_insertion_point(field_add:tron.OpParam.arg)
  return arg_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tron::Argument >*
OpParam::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:tron.OpParam.arg)
  return &arg_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tron::Argument >&
OpParam::arg() const {
  // @@protoc_insertion_point(field_list:tron.OpParam.arg)
  return arg_;
}

// -------------------------------------------------------------------

// NetParam

// optional string name = 1;
inline bool NetParam::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetParam::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetParam::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetParam::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& NetParam::name() const {
  // @@protoc_insertion_point(field_get:tron.NetParam.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetParam::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tron.NetParam.name)
}
inline void NetParam::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tron.NetParam.name)
}
inline void NetParam::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tron.NetParam.name)
}
inline ::std::string* NetParam::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tron.NetParam.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetParam::release_name() {
  // @@protoc_insertion_point(field_release:tron.NetParam.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetParam::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tron.NetParam.name)
}

// repeated .tron.Blob blob = 5;
inline int NetParam::blob_size() const {
  return blob_.size();
}
inline void NetParam::clear_blob() {
  blob_.Clear();
}
inline const ::tron::Blob& NetParam::blob(int index) const {
  // @@protoc_insertion_point(field_get:tron.NetParam.blob)
  return blob_.Get(index);
}
inline ::tron::Blob* NetParam::mutable_blob(int index) {
  // @@protoc_insertion_point(field_mutable:tron.NetParam.blob)
  return blob_.Mutable(index);
}
inline ::tron::Blob* NetParam::add_blob() {
  // @@protoc_insertion_point(field_add:tron.NetParam.blob)
  return blob_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tron::Blob >*
NetParam::mutable_blob() {
  // @@protoc_insertion_point(field_mutable_list:tron.NetParam.blob)
  return &blob_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tron::Blob >&
NetParam::blob() const {
  // @@protoc_insertion_point(field_list:tron.NetParam.blob)
  return blob_;
}

// repeated .tron.OpParam op = 11;
inline int NetParam::op_size() const {
  return op_.size();
}
inline void NetParam::clear_op() {
  op_.Clear();
}
inline const ::tron::OpParam& NetParam::op(int index) const {
  // @@protoc_insertion_point(field_get:tron.NetParam.op)
  return op_.Get(index);
}
inline ::tron::OpParam* NetParam::mutable_op(int index) {
  // @@protoc_insertion_point(field_mutable:tron.NetParam.op)
  return op_.Mutable(index);
}
inline ::tron::OpParam* NetParam::add_op() {
  // @@protoc_insertion_point(field_add:tron.NetParam.op)
  return op_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tron::OpParam >*
NetParam::mutable_op() {
  // @@protoc_insertion_point(field_mutable_list:tron.NetParam.op)
  return &op_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tron::OpParam >&
NetParam::op() const {
  // @@protoc_insertion_point(field_list:tron.NetParam.op)
  return op_;
}

// repeated .tron.Argument arg = 12;
inline int NetParam::arg_size() const {
  return arg_.size();
}
inline void NetParam::clear_arg() {
  arg_.Clear();
}
inline const ::tron::Argument& NetParam::arg(int index) const {
  // @@protoc_insertion_point(field_get:tron.NetParam.arg)
  return arg_.Get(index);
}
inline ::tron::Argument* NetParam::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:tron.NetParam.arg)
  return arg_.Mutable(index);
}
inline ::tron::Argument* NetParam::add_arg() {
  // @@protoc_insertion_point(field_add:tron.NetParam.arg)
  return arg_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tron::Argument >*
NetParam::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:tron.NetParam.arg)
  return &arg_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tron::Argument >&
NetParam::arg() const {
  // @@protoc_insertion_point(field_list:tron.NetParam.arg)
  return arg_;
}

// -------------------------------------------------------------------

// ModelInfo

// optional string project = 1;
inline bool ModelInfo::has_project() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelInfo::set_has_project() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelInfo::clear_has_project() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelInfo::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_project();
}
inline const ::std::string& ModelInfo::project() const {
  // @@protoc_insertion_point(field_get:tron.ModelInfo.project)
  return project_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_project(const ::std::string& value) {
  set_has_project();
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tron.ModelInfo.project)
}
inline void ModelInfo::set_project(const char* value) {
  set_has_project();
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tron.ModelInfo.project)
}
inline void ModelInfo::set_project(const char* value, size_t size) {
  set_has_project();
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tron.ModelInfo.project)
}
inline ::std::string* ModelInfo::mutable_project() {
  set_has_project();
  // @@protoc_insertion_point(field_mutable:tron.ModelInfo.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo::release_project() {
  // @@protoc_insertion_point(field_release:tron.ModelInfo.project)
  clear_has_project();
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_project(::std::string* project) {
  if (project != NULL) {
    set_has_project();
  } else {
    clear_has_project();
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:tron.ModelInfo.project)
}

// optional string version = 2;
inline bool ModelInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelInfo::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& ModelInfo::version() const {
  // @@protoc_insertion_point(field_get:tron.ModelInfo.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tron.ModelInfo.version)
}
inline void ModelInfo::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tron.ModelInfo.version)
}
inline void ModelInfo::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tron.ModelInfo.version)
}
inline ::std::string* ModelInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:tron.ModelInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo::release_version() {
  // @@protoc_insertion_point(field_release:tron.ModelInfo.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:tron.ModelInfo.version)
}

// optional string method = 3;
inline bool ModelInfo::has_method() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelInfo::set_has_method() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelInfo::clear_has_method() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelInfo::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_method();
}
inline const ::std::string& ModelInfo::method() const {
  // @@protoc_insertion_point(field_get:tron.ModelInfo.method)
  return method_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_method(const ::std::string& value) {
  set_has_method();
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tron.ModelInfo.method)
}
inline void ModelInfo::set_method(const char* value) {
  set_has_method();
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tron.ModelInfo.method)
}
inline void ModelInfo::set_method(const char* value, size_t size) {
  set_has_method();
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tron.ModelInfo.method)
}
inline ::std::string* ModelInfo::mutable_method() {
  set_has_method();
  // @@protoc_insertion_point(field_mutable:tron.ModelInfo.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo::release_method() {
  // @@protoc_insertion_point(field_release:tron.ModelInfo.method)
  clear_has_method();
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    set_has_method();
  } else {
    clear_has_method();
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:tron.ModelInfo.method)
}

// -------------------------------------------------------------------

// MetaNetParam

// optional string name = 1;
inline bool MetaNetParam::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaNetParam::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaNetParam::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaNetParam::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MetaNetParam::name() const {
  // @@protoc_insertion_point(field_get:tron.MetaNetParam.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetaNetParam::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tron.MetaNetParam.name)
}
inline void MetaNetParam::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tron.MetaNetParam.name)
}
inline void MetaNetParam::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tron.MetaNetParam.name)
}
inline ::std::string* MetaNetParam::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tron.MetaNetParam.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetaNetParam::release_name() {
  // @@protoc_insertion_point(field_release:tron.MetaNetParam.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetaNetParam::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tron.MetaNetParam.name)
}

// optional .tron.ModelInfo model_info = 2;
inline bool MetaNetParam::has_model_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaNetParam::set_has_model_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaNetParam::clear_has_model_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaNetParam::clear_model_info() {
  if (model_info_ != NULL) model_info_->::tron::ModelInfo::Clear();
  clear_has_model_info();
}
inline const ::tron::ModelInfo& MetaNetParam::model_info() const {
  // @@protoc_insertion_point(field_get:tron.MetaNetParam.model_info)
  return model_info_ != NULL ? *model_info_ : *default_instance_->model_info_;
}
inline ::tron::ModelInfo* MetaNetParam::mutable_model_info() {
  set_has_model_info();
  if (model_info_ == NULL) {
    model_info_ = new ::tron::ModelInfo;
  }
  // @@protoc_insertion_point(field_mutable:tron.MetaNetParam.model_info)
  return model_info_;
}
inline ::tron::ModelInfo* MetaNetParam::release_model_info() {
  // @@protoc_insertion_point(field_release:tron.MetaNetParam.model_info)
  clear_has_model_info();
  ::tron::ModelInfo* temp = model_info_;
  model_info_ = NULL;
  return temp;
}
inline void MetaNetParam::set_allocated_model_info(::tron::ModelInfo* model_info) {
  delete model_info_;
  model_info_ = model_info;
  if (model_info) {
    set_has_model_info();
  } else {
    clear_has_model_info();
  }
  // @@protoc_insertion_point(field_set_allocated:tron.MetaNetParam.model_info)
}

// repeated .tron.NetParam network = 11;
inline int MetaNetParam::network_size() const {
  return network_.size();
}
inline void MetaNetParam::clear_network() {
  network_.Clear();
}
inline const ::tron::NetParam& MetaNetParam::network(int index) const {
  // @@protoc_insertion_point(field_get:tron.MetaNetParam.network)
  return network_.Get(index);
}
inline ::tron::NetParam* MetaNetParam::mutable_network(int index) {
  // @@protoc_insertion_point(field_mutable:tron.MetaNetParam.network)
  return network_.Mutable(index);
}
inline ::tron::NetParam* MetaNetParam::add_network() {
  // @@protoc_insertion_point(field_add:tron.MetaNetParam.network)
  return network_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tron::NetParam >*
MetaNetParam::mutable_network() {
  // @@protoc_insertion_point(field_mutable_list:tron.MetaNetParam.network)
  return &network_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tron::NetParam >&
MetaNetParam::network() const {
  // @@protoc_insertion_point(field_list:tron.MetaNetParam.network)
  return network_;
}

// repeated .tron.Argument arg = 12;
inline int MetaNetParam::arg_size() const {
  return arg_.size();
}
inline void MetaNetParam::clear_arg() {
  arg_.Clear();
}
inline const ::tron::Argument& MetaNetParam::arg(int index) const {
  // @@protoc_insertion_point(field_get:tron.MetaNetParam.arg)
  return arg_.Get(index);
}
inline ::tron::Argument* MetaNetParam::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:tron.MetaNetParam.arg)
  return arg_.Mutable(index);
}
inline ::tron::Argument* MetaNetParam::add_arg() {
  // @@protoc_insertion_point(field_add:tron.MetaNetParam.arg)
  return arg_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tron::Argument >*
MetaNetParam::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:tron.MetaNetParam.arg)
  return &arg_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tron::Argument >&
MetaNetParam::arg() const {
  // @@protoc_insertion_point(field_list:tron.MetaNetParam.arg)
  return arg_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tron

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tron_2eproto__INCLUDED
